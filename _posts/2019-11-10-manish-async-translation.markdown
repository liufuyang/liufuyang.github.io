---
layout: post
title:  "Tokio 和 Async IO 到底都是些啥玩意?"
date:   2019-11-10
comments: true
---

我已经关注Rust一段时间了, 也在慢慢自学一些相关内容. 最近
Async IO, 也就是异步IO的一些标准语法也已经包含在了Rust
稳定版本里面比如 `async` 和 `await` 关键字.

可我之前在学习Async IO的过程当中, 一直有些疑惑. 比如那些经常听说的库 `tokio`, `mio`, `futures` 等等, 
到底都是干嘛用的? Rust的 Async IO 和 其他语言, 比如Go的协程, 是不是类似的概念?

后来无意当中搜到了Manish Goregaokar(Mozilla的一名研究工程师, 参与搭建火狐浏览器核心引擎)在2018年1月写的一篇博文:
[What Are Tokio and Async IO All About?](https://manishearth.github.io/blog/2018/01/10/whats-tokio-and-async-io-all-about/). 
读完之后有一种豁然开朗的感觉. 虽然现在已经过了挺久,
有些内容也已经稍微陈旧, 但我觉得还是很好的一篇适合入门者了解
Rust Async IO的博文. 特此尝试翻译成中文, 方便大家学习.
如果您有任何疑问或者建议, 非常欢迎您在本文下方留言.

Translation of Manish's orignal blog has been approved by the original author.
翻译已经获得原作者Manish Goregaokar的许可. 下面开始正文.

---
<br>

# **Tokio 和 Async IO 到底都是些啥玩意?**
# What Are Tokio and Async IO All About?

作者: [Manish Goregaokar](https://manishearth.github.io/blog/2018/01/10/whats-tokio-and-async-io-all-about/).
写于2018-01-10.

近期, Rust社区在“Async IO”上投入大量关注, 很多
工作在这个叫 [tokio](https://github.com/tokio-rs/)
的库上展开. 这非常棒!

但是对社区内部很多不和网络服务器等等打交道的同学来说,
还是挺难搞清楚那些人们在 Async 这块开发是想要达成怎样的目.
当人们在 (Rust) 1.0版本出来的时候谈论与此相关的话题时, 
我也是一头雾水, 从来没有接手过相关的工作.

Async IO 到底都是在搞啥? 协程又是什么东西? 
轻线程(lightweight thread)呢? 这些概念直接有关系吗?

# **我们在想解决怎样的问题?**

Rust 的一个卖点就是“并发不可怕”. 但是那种,
需要管理大量输入输出所限的任务的并发 - 那种能在Go, 
Elixir, Erlang 这类语言里看到的并发方式 - 在
Rust 里并不存在.

打个比方, 比如说你想搞个网络服务器之类的东西,
来在任意单独的时刻来管理成千上万的请求(这种问题也被
称作 “[c10k](https://en.wikipedia.org/wiki/C10k_problem)问题”). 总之来说, 我们要解决的问题有着极大量的输入输出 (I/O, 通常是网络I/O) 所相关的任务.

“同时管理N件事儿”非常适合来用线程 thread 来实现. 但是...要创建上千个线程吗? 那听上去有点真太多了. 而且线程还挺“昂贵”: 每一个线程需要分配一个挺大的栈 stack, 建立线程需要经手不少系统调用, 而且系统上下文切换也非常耗资源.

当然了, 上千个线程也不可能真的能在CPU上真正同时运行. 你只有屈指可数的几个内核(core), 在某一时刻, 只有一个线程运行在一个核上.

但对于这种网络服务器类型的系统来说, (如果真去创建大量的线程的话), 其实大部分创建出来的线程都在不工作状态, 它们都会在做大量的网络等待. 这些线程要么在监听来访的请求 (request), 要么在等待回复 (response) 被发送出去.

所以你用这种普通线程的, 来调度这种输入输入的任务的时候, 系统调用把控制交付给操作系统内核, 然后内核并不会立马把控制返回给你, 因为输入或者输出还没有结束. 事实上, 此时系统内核会利用这个机会去换一个另外的线程来运行, 等输入输出操作结束后(比如, 等操作非阻塞 / unblock 的时候), 再换到你之前的线程上运行. 如果没有 Tokio 和那些兄弟类库的话, 你就得用这种本办法来解决这种问题. 创建超级多的线程, 让操作系统去做任务切换.

但是, 正如我们已经知晓的那样, 线程并不能很好的在这种问题上被拓展 (scale). 然而也有例外[见下方索引1].

我们需要比较“轻”的线程.

---

<br>

# **轻量级线程 - Lightweight 线程**

我认为一种容易理解轻量级线程的方法, 是暂时先不要管 Rust, 而看看 Go 是怎么做的. 因为 Go 在这一点公认做的很好.

Go不采用操作系统线程, 而是定义了一种轻量级线程, 叫做"goroutines". 你用 `go` 关键字来启动这种线程. 比如一个网络服务器可能这样来实现:

{% highlight golang %}
listener, err = net.Listen(...)
// handle err
for {
    conn, err := listener.Accept()
    // handle err

    // spawn goroutine:
    go handler(conn)
}
{% endhighlight %}

这里用一个循环, 等待新的 TCP 链接, 之后创建一个 goroutine , 这个 goroutine 会开始运行 `handler` 函数来响应得到的链接. 每一个链接都会成为一个新的 goroutine, 而且这个 goroutine 会在 `handler` 执行完毕之后被销毁. 与此同时, 主循环还在继续运行, 因为它跑在一个不同的 goroutine 上.

那么问题是, 如果并没有"真的"(操作系统)线程, 那这一切是怎样发生的?

Goroutine 是一种"轻量级"线程的实例. 操作系统并不知晓这种线程, 它只看到 N 个自己的线程被 Go 运行时(runtime)所拥有, 而 Go 运行时把 M 个 goroutines 映射到这 N 个操作系统上面 [见下方索引2]. Go 运行时负责来回切换那些 goroutine, 就如操作系统调度器一般. 它之所以能这么做事因为 Go 代码已经可以被中断进而进行垃圾回收, 所以 Go 运行时的调度器总可以让某个 goroutine 停下来. 这个调度器同时也知晓输入输出操作, 当一个 goroutine 等待输入输出时, 它会把自己"交还"(yields)给调度器.

本质上来说, 一个编译出来的 Go 函数会有一堆断点散落在其过程当中, 在每一个点上它会告诉调度器和垃圾回收"你要让我暂停?, 那好吧, CPU归你了" (或者"我正在等待, 你来接手CPU的使用吧")

当一个 goroutine 从系统线程上切走的时候, 一些寄存器会被保存, 程序计数器会切换到新来的 goroutine 上.

但之前这个 goroutine 的栈 stack 怎么办? 操作系统线程有一个很大的栈, 而且你基本上得有个栈才能让你写的函数或者代码来工作.

Go 之前采用的解决方法是用分段的栈(segmanted stacks). 对多数语言来说, 包括 C, 一个线程之所以需要一个很大的栈, 是因为它们需要一个连续的栈. 而且栈不能像那种随意增长的缓存一样被"从新分配/reallocated", 因为我们需要栈数据保持在原位, 以便那些指向栈上的指针们可以持续保持有效. 因此, 我们预留所有我们觉得需要的的空间在到栈上(大概8MB), 然后就只能寄希望于之后不需要更多了.

但是这种对于栈要连续的需求并不是严格必须的. 在 Go 里, 栈是由很多小的区块组成的. 当开始调用一个函数的时候, Go 会看一个栈上是否还有足够的空间来跑这个函数, 如果不够, 分配一块新的小空间作为栈, 然后让函数跑在上面. 所以如果你有上千个线程, 每个在做一些小量的工作, 它们总共占用着很多很小的小栈, 这就没什么问题.

现如今, Go 实际上采用了不同的一种方式. 它会[复制栈](https://blog.cloudflare.com/how-stacks-are-handled-in-go/). 我上面提到, 由于需要栈数据保持在原位, 栈不能被"从新分配/reallocated". 但其实这也不一定完全正确 - 因为 Go 还有垃圾回收, 它也知道每一个指针在哪里, 从而可以把指针重新定向到新的栈位置, 如果需要的话.

总之, 不管用分段的栈, 或者复制栈的方法, Go 的丰富的运行时可以让其很好的管理这些事务. Goroutines 非常廉价, 轻量, 你可以创建成千上万的 goroutine, 系统也不会有什么问题.

Rust 早先的时候支持轻量/"绿色"线程(我记得好像是用分段栈的方法). 但是, Rust 非常关心"不用的东西就不要花钱在上面", 所以如果支持轻量线程的话, 所有不需要轻量级线程的代码也得背上这个包袱. 因此 Rust 在1.0版本之前, 去掉了对轻量级线程的支持.

---
<br>

# **异步 I/O - Async I/O**

解决上述问题的一个关键基石就是异步 I/O. 如前所述, 如果采用常规的blocking I/O 的话, 当跟系统发出 I/O 请求的时候, 你的线程将被禁止继续运行(“被阻碍/blocked”), 直到 I/O 操作最终完成. 这如果是发生在操作系统线程的话就显得没什么问题(因为操作系统调度会帮你完成所有工作), 可如果这是发生在轻量线程上的话, 你得负责将这个blocked轻量线程从操作系统线程上换下来, 换上另一个轻量线程.

这如何实现呢? 你得采用非阻塞 I/O (non-blocking I/O) - 这时当你跟系统发出 I/O 请求的时候, 你的线程可以继续工作而不用停止. 这个 I/O 请求将会在一段时间之后被内核执行. 之后你的线程, 在尝试访问 I/O 结果之前, 需要问问操作系统:“请问我刚才提交的 I/O 请求完成了吗?”

当然了, 要是你一直不断的去询问操作系统好了没好了没, 肯定显得比较啰嗦而且耗费资源. 而这就是为什么会一类像 **`epoll`** 这样的系统调用存在. 采用这种方式, 你可以把一些没有完成的 I/O 请求打成一捆, 然后告诉操作系统, 如果这一捆操作里有任何一个完成之后, 来把我的线程唤醒. 像这样的话, 你就可以用一个线程(一个操作系统线程)来负责换下等待 I/O 操作的轻量级线程. 而且当没事情的时候(比如 I/O 操作都在等待的时候), 这个线程在执行完最后一个 `epoll` 之后就直接进入睡眠状态了, 直到某个 I/O 操作完成之后, 操作系统将其再次唤醒.

(真实的过程很可能比上述的描述复杂很多, 但你现在应该能了解个大概了)

那么好了, 现在我们要把同样但机理引入到 Rust 当中, 一种做法就是通过 Rust 的 [mio](https://github.com/tokio-rs/mio) 库. 这个库提供了一种与平台无关的一组打包好的函数, 其中包括 non-blocking I/O 和 相对于每个平台的异步系统调用, 比如 `epoll/kqueue` 等等. 这个库算是一个组件库, 即便那些在过去在 C 里面用 `epoll` 的人会觉得这个库比较有用, 这个库并没有提供一种像 Go 那样方便的编程模型. 但我们可以通过叠加其他组建来达成我们在 Rust 里也可以方便处理异步输入输出的目标.

---
<br>

# **Futures**

**Futures** 是另一块解决这个问题的基石. 一个 `Future` 好比一个将来总会有值返回的承诺 / promise (事实上, 在Javascript里, 这个概念就直接被叫做了 `Promise`也就是承诺).



 🗼

---
<br>

索引
1. 值得提醒一下并不是说创建大量线程是完全不可行的方案. 比如 Apache 就采用大量系统线程. 系统线程也经常可以在这种问题上被采用.
2. 轻量级线程也经常被叫做 M:N 线程 (也被称为"绿色线程/green thread").